= Anypoint Connector DevKit Tutorial
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: devkit tutorial, features, cookbook
:resourcesDir: resources
:tutorial: Cookbook
:author: MuleSoft Inc.

include::partial$devkit-important.adoc[]

== Tutorial Goals

Learn how to create a connector to a web service using the Anypoint Connector DevKit.

DevKit helps you build xref:3.8@mule-runtime::anypoint-connectors.adoc[Anypoint Connectors]. This tutorial shows you how to code a connector to support authentication, connections, service operations and more. This is functionality that you as the connector developer expose to the end user of the connector, who is the Mule application developer.

== What is the Anypoint Connector DevKit?

The xref:index.adoc[Anypoint Connector DevKit] is an essential development tool in the Anypoint Platform that makes coding Anypoint Connectors easier. DevKit is a Maven-based tool that lets you build reusable components that can be run as part of a Mule application, and can be easily configured from http://www.mulesoft.com/platform/mule-studio[Anypoint Studio].

DevKit exposes connector developers to http://docs.oracle.com/javase/tutorial/java/annotations/[Java annotations] that generate code and files to interact with Mule runtime, as well as Anypoint Studio. The generated code provides the interface between the connector and Mule that would otherwise require each connector developer to include extensive boilerplate code, as well as the code and files required to interact with your connector in Anypoint Studio.

== What is a Connector?

An Anypoint Connector is a reusable component that interacts with Mule runtime and Anypoint Studio. A connector communicates with a target resource and conveys information between a resource and Mule, and transforms the data into a Mule message.

Anypoint Connector DevKit abstracts the communication that happens between Mule and the external service or API, and generates a user interface to help simplify usage of the connector by the developer who would eventually use it in their application.

A well-developed connector makes Mule app development much simpler for users when handling tasks like pagination, session expirations, and input and output metadata. This tutorial shows you how to create a well-designed connector.

== Why Build a Connector Using DevKit?

Here is why you might want to build your own connector:

* You need to consume an API from a Mule application and you want to make sure your developers maintain consistency by employing the same connector.
* You have an API and want to add strategic value to your business by providing developers with a connector that provides an interface into your web service.
* You want to facilitate integration with SaaS and on-premises Web services, applications, and data sources.
* The API you consume supports Pagination, Batch, and/or has a SQL capability.
* The API you consume has different entity types and/or its structure changes depending on API/service operation.
* You want to extend Mule core.

== Prerequisites

Before developing a connector you should have a working knowledge of Mule, xref:6.x@studio::to-download-and-install-studio.adoc[Anypoint Studio], and Java development in general, specifically the use of https://docs.oracle.com/javase/tutorial/java/annotations/basics.html[Java annotations].

[NOTE]
====
For information on software setup and DevKit, see xref:setting-up-your-dev-environment.adoc[Setting Up Your Development Environment] and xref:index.adoc[Anypoint Connector DevKit].

*You can develop a connector on a Windows, Mac, or Linux machine.*
====


[[get-cookbook]]
== Get the Cookbook

Get the cookbook tutorial, which is stored on GitHub:

. Clone the https://github.com/mulesoft/mule-cookbook[https://github.com/mulesoft/mule-cookbook] repository into your local machine. For example, to clone to your desired development folder, run:
+
[source,console,linenums]
----
cd ~/dev
git clone https://github.com/mulesoft/mule-cookbook.git
----
+
. Enter your newly created `mule-cookbook` directory and run the following Maven command:
+
[source,console,linenums]
----
mvn install eclipse:eclipse
----
+
////
As the connector has not yet been built, you should receive a FAILURE to build the Mule Cookbook Anypoint Connector
todo
[INFO] Reactor Summary:
[NOTE]
[INFO] mule-cookbook ...................................... SUCCESS [  1.002 s]
[INFO] model .............................................. SUCCESS [  1.823 s]
[INFO] webservice ......................................... SUCCESS [  2.161 s]
[INFO] soap-server ........................................ SUCCESS [  9.675 s]
[INFO] rest-server ........................................ SUCCESS [  2.729 s]
[INFO] Mule Cookbook Server Application ................... SUCCESS [ 11.379 s]
[INFO] sdk-client ......................................... SUCCESS [  6.066 s]
[INFO] Mule Cookbook Anypoint Connector ................... FAILURE [ 12.956 s]
[INFO] mule-cookbook-service .............................. SKIPPED
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
////
. When done, open Anypoint Studio, import the `mule-cookbook` directory as an existing project. *File* > *Import* > *Existing Projects into Workspace*.
+
image::devkit-tutorial-30756.png[import existing - mule-cookbook]

This should create the several folders you see on the above screen in your workspace in Studio, which is visible in the *Package Explorer*.

== Cookbook Description

Before we move on, let us briefly mention that the Cookbook service is a web service that helps users organize ingredients and recipes they might like to access, store or update from the web.

=== Cookbook API Description

This API allows users to use the create, read, update, and delete (CRUD) operations for single and multiple recipes and ingredients. The API also allows you to view recently added recipes.

The API is exposed as a:

* SOAP Service using a  https://github.com/mulesoft/mule-cookbook-tutorial/blob/master/src/main/resources/wsdl/IMuleCookBookService.wsdl[WSDL] file
* REST API with a https://github.com/mulesoft/mule-cookbook-tutorial/blob/master/src/main/asciidoc/resources/api.raml[RAML] file, and
* a Java https://github.com/mulesoft/mule-cookbook-tutorial/blob/master/src/main/asciidoc/resources/java/IMuleCookBookClient.java[SDK].


=== Authentication

This connector supports the following authentication mechanisms:

* Custom authentication with a username and password that provides a token to send with each request as part of the request.

* http://oauth.net/2/[OAuthV2]

==== Credentials

===== Custom Authentication:
[%header,cols="2*"]
|===
| Username
| Password

| admin
| admin
|===

===== OAuth:
[%header,cols="2*"]
|===
| Client ID
| Client Secret

| ePU9CxyEVFIXF9nMoGH16s1lUGe5JYPPzClnnVBG
| YeKAsQCdr264tNmDdvTdJUAh9TQraJqZpwbEoTuz
|===

[[connecting-to-service]]
=== Connecting to the Service

The web service is available online.

* To consume the SOAP version and the SDK just make the request to the address: `+http://devkit-cookbook.cloudhub.io/soap+`.

* The rest base url is `+http://devkit-cookbook.cloudhub.io/rest+`

** The OAuth Authorize url is */oauth/authorize*

** The Access Token url is */oauth/accessToken*

[NOTE]
====
You can also run it locally since we provide the source code for the servers already ready to start.

The local SOAP Server can be run from the soap-server project by simply executing the com.cookbook.tutorial.service.MuleStoreServer class.

By default it starts the server at address `+http://localhost:9090/cook-book+`

The local REST Server can be run from the rest-server project by simply executing the com.cookbook.tutorial.Main class.

By default it starts the server at address `+http://localhost/9091+`
====

== Steps to Build the Cookbook Connector

To build a basic connector for the {tutorial} service, we need to perform the following steps:

. Create a Connector Project.
. Add the dependency that contains the client we will use to connect to the service.
. Add a configurable URL so that users can specify the URL where the service is hosted.
. Add an operation that users can consume in Anypoint Studio.

=== Create the {tutorial} Connector

With the `mule-cookbook` directory imported as an existing project into your workspace as instructed <<get-cookbook,above>>, you can begin to create the connector project and start coding.

. In Anypoint Studio, click *File* > *New* > *Anypoint Connector Project* or right-click your project name in Package Explorer and click *New* > *Anypoint Connector Project*:
+
image::new-connector-1.png[width="500"]
+
. Select the project type you want to create. In this case, select *SDK Based*:
+
image::new0.png[width="500"]
+
. Specify the name of your connector and don't forget to uncheck the default generation before clicking *Finish*:
+
image::new1.png[width="550"]
+
This generates a project containing the structure and all required elements including a skeleton connector, icons, sample docs file, but no basic tests for your connector.
+
image::new-connector-3.png["",width="600"]

[TIP]
You can enable the DevKit view by clicking from the top bar *Window* > *Show View* > *Other*, and look for DevKit in the *MuleSoft* dropdown.


.DevKit View shows a compact view of the connector.
image::enable-view.png[width="300"]

[[using-config]]
== Connection Configuration

When consuming a service, you may need to configure different values to establish a connection.

To facilitate developing connection configuration strategies, DevKit provides a pair of annotations that let you modularize these definitions inside several classes:

* The behavior you expose to users, using the `@Connector` annotation.
* Code related to the connection configuration is injected where you add the `@Config` annotation. There are several types of configuration you can use as we will see in this tutorial.

[TIP]
====
When you mark a class with `@Config`, DevKit ensures that you have an initialized object set when the Mule app runs and that requests are made to your connector.
====

=== Add Dependencies in pom.xml

Let's start coding by creating a connector that allows you to get the recently added items from the Cookbook service.

Since we don't need any kind of authentication to consume the recently added recipes, this is the best operation we can use to start learning how to build our connector.

. Add our client dependency so that we can use it in our connector. This way we can use the Java API to connect to the {tutorial}.
+
In your pom.xml file add:
+
[source,xml,linenums]
----
<dependencies>
  <dependency>
    <groupId>org.mule.modules</groupId>
    <artifactId>sdk-client</artifactId>
    <version>1.0.0-SNAPSHOT</version>
  </dependency>
</dependencies>
----

=== Adding Code to Support Configurable Fields

In the `ConnectorConfig.java` file add the @Configurable annotation for the address where the {tutorial} service is hosted:

. Type *conf* at the editor of your connector config and use `control` + `space` to display the templates.
+
image::config-field.png[width="600"]
+
. Define a configurable field inside the `@Configuration`-annotated class with a default value for the endpoint our client connects to, for example, `@Default("http://devkit-cookbook.cloudhub.io/soap")`
. Any field marked with the `@Configurable` annotation must have a getter and a setter for that field.
+
See full https://github.com/mulesoft/mule-cookbook-tutorial/blob/master/src/main/asciidoc/resources/java/v1/ConnectorConfig.java[Config] source code.

=== Initialize the Client

In your `@Connector`-annotated class in the `Connector.java` file use the `@Start` annotation on a method to initialize the client.

[source,java,linenums]
----
include::{examplesdir}/java/v1/CookbookConnector.java[lines=30..35]
----

[NOTE]
====
Anypoint Connectors are made to be fully aware of Mule runtime's lifecycle without implementing any Mule-specific interface.

There is an annotation method for each of the four phases of the lifecycle.

When a method is annotated with one of these annotations, DevKit invokes it during the lifecycle phase that the annotation represents.
====

[[processor]]
=== Adding @Processor Methods

. Remove the dummy `@Processor` operation from the `Connector.java` file.
+
. To add a processor simply type `proc` in the Studio code editor and use `ctrl` + `space` to display the templates and pick the simple processor.
+
image::processor1.png[width="600"]
+
. Change it to reflect the `getRecentlyAdded` method signature (see example implementation https://github.com/mulesoft/mule-cookbook-tutorial/blob/master/src/main/asciidoc/resources/java/v1/CookbookConnector.java#L46[here]), and at this point you have the code in place to build your first connector, which should then be ready for testing.
. Run the xref:creating-a-java-sdk-based-connector.adoc#generating-sources[Generate Sources] Action.
+
See full https://github.com/mulesoft/mule-cookbook-tutorial/blob/master/src/main/asciidoc/resources/java/v1/CookbookConnector.java[Connector] source code.

[NOTE]
Resolve any package import errors by right-clicking your connector project in the Package Explorer of Studio. *Build Path* > *Add External Archives*. Add the applicable .jar files, for example, so your project can reference the cookbook `sdk-client`. This should stop any import errors on:
`import com.cookbook.tutorial.client.MuleCookBookClient;`
`import com.cookbook.tutorial.service.Recipe;`

You can check references in the properties for your project.

image::devkit-tutorial-af283.png[properties for cookbook connector project]

At this point you can <<install-guide,install>> this Connector and try it in Studio if you want.

[IMPORTANT]
====
As you modify your connector, you may start seeing error markers on the generated folder.

Just ignore them.

Once you regenerate the sources, the errors will go away as the generated code will be refreshed.
====

==== Defining Example Code for Connector Processors

[NOTE]
Connectors built with DevKit 3.8 support specification of examples in a different format. See the new specification and generation format at xref:connector-reference-documentation.adoc[Connector Reference Documentation].

Follow along to add an example use for an operation (annotated with `@Processor`).

Create the file referenced in the code block in the `Connector.java` file following `{@sample ...}` if the file does not exist already.

----
/**
 * Returns the list of recently added recipes
 *
 * {@sample.xml ../../../doc/cookbook-connector.xml.sample
 * cook-book:getRecentlyAdded}
 *
 * @return A list of the recently added recipes
 */
----

[NOTE]
When you add an example, use the same name as the one that specifies the example in the file. Inside of it you have to put an example of the `@Processor`.

If you have the "Javadoc check" enabled, the DevKit plugin marks the missing example as an error and provides a quick fix for us to easily add the example.

Otherwise, open the file and type *<* at the editor and use `control` + `space` to display the templates and pick the one that best suits our operation.

image::sample1.png[width="600"]

Our example in this case looks like this:

[source,xml,linenums]
----
<!-- BEGIN_INCLUDE(cook-book:getRecentlyAdded) -->
	<cook-book:get-recently-added/>
<!-- END_INCLUDE(cook-book:getRecentlyAdded) -->
----

=== Using the Connector in a Mule App

Make a simple app that listens at an HTTP endpoint; when the endpoint is hit, the app retrieves the list of recently added items from the cookbook service using the connector.

. Create a Mule application in Studio and add an HTTP listener and specify `/get-recently` for the path.
. Drop the connector onto the canvas and configure using `admin` and `admin` as the credentials (this is for non-OAuth configuration).
+
image::devkit-tutorial-4cb84.png[]
+
. Drag and drop an *Object to JSON* transformer after the connector, and run the app. (Play icon or *Run As* > *Mule Application*)
+
image::devkit-tutorial-1c0f8.png[]
+
[source,xml,linenums]
----
include::{examplesdir}/mule-app/first-mule-app.xml[]
----
+
If you hit the url `+http://localhost:8081/get-recently+` you will see a reply similar to:
+
[source,json,linenums]
----
[
   {
      "created":1428678371866,
      "id":2,
      "lastModified":null,
      "name":"Baked Apples",
      "cookTime":20.0,
      "directions":[
         "Cut the Apples",
         "Put them in the oven",
         "Remove from the oven after 20.0 minutes"
      ],
      "ingredients":[
         {
            "created":1428678371866,
            "id":1,
            "lastModified":null,
            "name":"Apple",
            "quantity":0.0,
            "unit":"UNIT"
         }
      ],
      "prepTime":30.0
   }
]
----


To learn how to create tests for your connector see:

* http://mulesoft.github.io/connector-certification-docs/advanced/index.html#_functional_tests_automation[Tests Automation] documentation.

* The full xref:developing-devkit-connector-tests.adoc[testing documentation].

=== Adding Connection Management

The `getRecentlyAdded` call doesn't require authentication -- all other Cookbook operations require that you set a token on each request.

The client you are using provides a login call that initializes the token and uses it in subsequent requests.

[NOTE]
====
Take into account that the session can expire and cause the connector to make a login request again.
====

DevKit provides a set of annotations to keep your code clean and handle the connection.

. In the `Config.java` file, change `@Configuration` to `@ConnectionManagement`
+
[source,java,linenums]
----
include::{examplesdir}/java/v2/ConnectorConfig.java[lines=29]
----
+
. Make sure you have equipped the `MuleCookbookClient` in the `ConnectorConfig.java` with a getter and a setter.
+
[source,java,linenums]
----
include::{examplesdir}/java/v2/ConnectorConfig.java[lines=91..100]
----
+
. Implement these four methods as shown:
+
* *`@Connect`* - Initialize the client, and if the login does not succeed, throw an exception.
+
[source,java,linenums]
----
include::{examplesdir}/java/v2/ConnectorConfig.java[lines=41..50]
----
+
* *`@Disconnect`* - Release a connection.
+
[source,java,linenums]
----
include::{examplesdir}/java/v2/ConnectorConfig.java[lines=55..58]
----
+
* *`@ValidateConnection`* - Check if your connection is alive.
+
[source,java,linenums]
----
include::{examplesdir}/java/v2/ConnectorConfig.java[lines=63..66]
----
+
* *`@ConnectionIdentifier`* - Return a string value. This will only be used when debugging.
+
[source,java,linenums]
----
include::{examplesdir}/java/v2/ConnectorConfig.java[lines=71..74]
----
+
. Remove the declaration of `MuleCookBookClient` from  `CookbookConnector.java` and remove the method where a new `MuleCookBookClient` client is instantiated.
+
[source,java,linenums]
----
	private MuleCookBookClient client;

	@Start
	public void initialize() {
		client = new MuleCookBookClient(config.getAddress());
	}
----
+
. In our `getRecentlyAdded` method (annotated as a `@Processor`) call the `getclient` method, which should be defined in `ConnectorConfig.java`.
+
[source,java,linenums]
----
include::{examplesdir}/java/v2/CookbookConnector.java[lines=35..38]
----

See:

* https://github.com/mulesoft/mule-cookbook-tutorial/blob/master/src/main/asciidoc/resources/java/v2/CookbookConnector.java[Connector] source code.

* https://github.com/mulesoft/mule-cookbook-tutorial/blob/master/src/main/asciidoc/resources/java/v2/ConnectorConfig.java[Config] source code.

If you install this version and try to run the Mule app we created earlier, you will see that it fails with a "SAXParseException" because we need to add a username and password to our configuration.

Just open the global configuration of your connector and check that there are two new fields, username and password. Configure them and you can run the app again.

image::connection-management.png[width="600"]

This is the updated Mule app XML:

[source,xml,linenums]
----
<?xml version="1.0" encoding="UTF-8"?>

<mule xmlns:cookbook="http://www.mulesoft.org/schema/mule/cookbook" xmlns:json="http://www.mulesoft.org/schema/mule/json" xmlns:http="http://www.mulesoft.org/schema/mule/http" xmlns="http://www.mulesoft.org/schema/mule/core" xmlns:doc="http://www.mulesoft.org/schema/mule/documentation"
      xmlns:spring="http://www.springframework.org/schema/beans"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-current.xsd
http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd
http://www.mulesoft.org/schema/mule/json http://www.mulesoft.org/schema/mule/json/current/mule-json.xsd
http://www.mulesoft.org/schema/mule/cookbook http://www.mulesoft.org/schema/mule/cookbook/current/mule-cookbook.xsd">
    <http:listener-config name="HTTP_Listener_Configuration" host="0.0.0.0" port="8081" doc:name="HTTP Listener Configuration"/>
    <cookbook:config name="Cookbook__Configuration" doc:name="Cookbook: Configuration type config" password="admin" username="admin"/>
    <flow name="mule-appFlow">
        <http:listener config-ref="HTTP_Listener_Configuration" path="/get-recently" doc:name="HTTP"/>
        <cookbook:get-recently-added config-ref="Cookbook__Configuration" doc:name="Cookbook"/>
        <json:object-to-json-transformer doc:name="Object to JSON"/>
    </flow>
</mule>
----

* Understand http://mulesoft.github.io/connector-certification-docs/advanced/index.html#_test_connectivity[Testing Connectivity].
* See documentation on setting up xref:authentication.adoc[Authentication] using DevKit.

== Improving Exception and Error Handling

This section explains how to improve exception handling and reconnecting.

=== Exception Handling with @Handler

The `@Handler` feature is useful for avoiding duplicate code for handling exceptions, and makes your code easier to read.

When handling messages retrieved from the API, if you see the message is uninformative and you know how to improve it, use the `@Handler` mechanism to enrich the error information provided to the user.

To see how it works, let's create a handler in the connector code for the `InvalidEntityException` thrown by the Cookbook SDK `create()` call:

.This `create()` call from `MuleCookBookClient.java` throws `InvalidEntityException`
[source,java,linenums]
----
@Override
   public CookBookEntity create(CookBookEntity entity) throws InvalidEntityException,
           SessionExpiredException {
       Create request = factory.createCreate();
       request.setEntity(entity);
       try {
           return port.create(request, token).getReturn();
       } catch (InvalidTokenException e) {
           logger.warn("Should never happen.", e);
           throw new RuntimeException(e);
       }
     }
----

. Create a new *Anypoint Connector Component* by right-clicking and navigating to that item in the menu, or via *New* > *Other*, selecting this option in the wizard.
+
image::new-component.png[width="600"]
+
. Select the package, component type and class name and click on Finish.
+
image::new-component-2.png[width="600"]
+
. Improve the error message when `InvalidEntityException` is thrown.
+
[source,java,linenums]
----
include::{examplesdir}/java/v3/CookbookHandler.java[lines=11..19]
----
+
Check the full https://github.com/mulesoft/mule-cookbook-tutorial/blob/master/src/main/asciidoc/resources/java/v3/CookbookHandler.java[source code].
+
. Add a new processor to create Ingredients, noticing how it references the exception handler we included.
+
[source,java,linenums]
----
include::{examplesdir}/java/v3/CookbookConnector.java[lines=59..63]
----
+
Check the full https://github.com/mulesoft/mule-cookbook-tutorial/blob/master/src/main/asciidoc/resources/java/v3/CookbookConnector.java[source code].

=== Handling Session Expiration

There is no need for users to add custom code in their Mule apps to handle session expiration. DevKit provides a mechanism to do this cleanly.

Just annotate your `@Processor` method with the `@ReconnectOn` exception.

[source,java,linenums]
----
include::{examplesdir}/java/v3/CookbookConnector2.java[lines=60..65]
----

Check the full https://github.com/mulesoft/mule-cookbook-tutorial/blob/master/src/main/asciidoc/resources/java/v3/CookbookConnector2.java[source code].

In our Mule app, you can configure a reconnection strategy so that our Mule app is ready to  handle session expirations.

Global Configuration for the Cookbook connector dialog window:

image::reconnect.png[width="500"]

The generated XML for the Cookbook connector configuration element looks like:
[source,xml,linenums]
----
<cookbook:config-type doc:name="config" name="config" password="admin" username="admin">
    <reconnect/>
</cookbook:config-type>
----

== Adding DataSense

=== What is it?

DataSense improves the user experience at design time when creating Mule applications by enabling your connector to determine the API of your target resource.

Even though DataSense is optional, its use enables connector users to acquire metadata of the entities in a service.

See:

* xref:adding-datasense.adoc[Adding DataSense]


In this tutorial, we use a static DataSense model, which means that the entities are fixed and known upfront, and do not change. The fields that this model supports are also fixed.

=== Using DataSense

To use DataSense in the cookbook:

. Analyze the entities in \{mule} service. We only have two simple entities, Recipe and Ingredient that both extend from CookBookEntity.
. Look at how our createIngredient operation looks inside Anypoint Studio, and how it interacts with other components.
+
[source,java,linenums]
----
include::{examplesdir}/java/v3/CookbookConnector2.java[lines=60..65]
----

==== Handling Ingredients

We defined the operation so that it receives an Ingredient, and it returns an Ingredient with the extra fields populated from the server.

Let's handle the ingredients:

. Check the input metadata to see that the expected output is a POJO, with the expected fields our Ingredient has:
+
image::datasense-expected-ingredients.png[width="800"]
+
. Verify that the output metadata is expected:
+
image::datasense-ingredients.png[width="800"]
+
. Drag and drop a Transform Message element either behind or after our connector. The input/output structure is collected automatically:
+
image::datasense-input.png[title="Transform Message Receiving Connector Output", width="800"]
+

Because DevKit auto-generates static metadata, DevKit automatically ensures that your connector knows how to propagate metadata information.

==== Handling Recipes

We don't have just Ingredients, we also have Recipes, so we don't want one method for each entity we have in our model.

Modify your connector to just work with the CookBookEntity class:

. Create an operation:
+
[source,java,linenums]
----
include::{examplesdir}/java/v4/CookbookConnector.java[lines=64..69]
----
+
. The *@RefOnly* annotation is used to tell DevKit that the input can only be specified as a reference (due to a DevKit limitations on handling Abstract classes).
+
Let's see how this affects the UI and user experience.
+
Studio, can no longer determine input or output type:
+
image::ref-only-input.png[title="Connector Input with @RefOnly",width="900"]
+
image::ref-only-output.png[title="Connector Output with Abstract Class",width="900"]

In the next section we get back our DataSense-friendly user experience.

The full source code of our connector with a create, update, get and delete operation is available https://github.com/mulesoft/mule-cookbook-tutorial/blob/master/src/main/asciidoc/resources/java/v4/CookbookConnector.java[here].

=== Implementing a MetaDataCategory

To implement DataSense using a @MetaDataCategory, you need to separate your implementation in two steps, retrieving the keys and describing the keys.

. Use the Anypoint DevKit Component wizard to create a new MetaDataCategory
+
image::new-metadatacategory.png[width="600"]
+
. Modify the method annotate with @MetaDataKeyRetriever to retrieve two keys, one for Recipe and another for Ingredient.
+
[source,java,linenums]
----
include::{examplesdir}/java/v5/DataSenseResolver.java[lines=28..37]
----
+
. Modify the method annotate with @MetaDataRetriever, to retrieve the description. Because we use a static model, we can just create a POJO model:
+
[source,java,linenums]
----
include::{examplesdir}/java/v5/DataSenseResolver.java[lines=48..65]
----
+
Check the full https://github.com/mulesoft/mule-cookbook-tutorial/blob/master/src/main/asciidoc/resources/java/v5/DataSenseResolver.java[source code].

To use this in our connector, modify our @Processors so that a user can pick the entities.

. Annotate our @Connector class with the @MetaDataScope annotation. This sets the default MetaDataCategory that's used every time users choose a @Processor that has a @MetaDataKeyParam.
+
[source,java,linenums]
----
include::{examplesdir}/java/v5/CookbookConnector.java[lines=35..37]
----
+
. To describe input and output, add a String annotated with *@MetaDataKeyParam*, and specify that it affects input and output by adding the *affects=MetaDataKeyParamAffectsType.BOTH* :
+
[source,java,linenums]
----
include::{examplesdir}/java/v5/CookbookConnector.java[lines=69..75]
----
+
. In your get operation you need specify that the affect only applies to the output so we modify it just a little:
+
[source,java,linenums]
----
include::{examplesdir}/java/v5/CookbookConnector.java[lines=115..121]
----
+
. Check our new connector looks in Studio. We have a combo after we select the entity type and save it. This automatically refreshes our metadata.
+
image::datasense-static.png[width="800"]
+
Now even the \{dataWeave} knows how to interact with our @Connector:
+
image::datasense-static2.png[width="800"]

View connector full source code https://github.com/mulesoft/mule-cookbook-tutorial/blob/master/src/main/asciidoc/resources/java/v5/CookbookConnector.java[here].

==== Dynamic DataSense

In the previous section we covered the scenario when your model is static. Let's take a look into a much more complex scenario.

There are APIs that provide a way to get entity definitions dynamically. Salesforce, NetSuite are just some examples of these.

In our case, our Cookbook provides an operation that describes our entities, so let's use that instead to get the entities and structure:

. Get the supported entities, and generate a key that we can use later:
+
[source,java,linenums]
----
include::{examplesdir}/java/v6/DataSenseResolver.java[lines=39..51]
----
+
. Use a structure that we can dynamically modify, and the way to do this in Mule is by using a +Map<String,Object>+ as parameters and/or return types of our connector.
+
Mule provides a builder that helps us generate the MetaData for the entities.
+
[source,java,linenums]
----
include::{examplesdir}/java/v6/DataSenseResolver.java[lines=60..87]
----
+
. Check the full https://github.com/mulesoft/mule-cookbook-tutorial/blob/master/src/main/asciidoc/resources/java/v6/DataSenseResolver.java[source code].
+
. In our @Connector now we need to add the code to generate the entities from the Map, and return Map in all our operations. Why is this important? To maintain consistency in our API.
+
This is how our new Create looks:
+
[source,java,linenums]
----
include::{examplesdir}/java/v6/CookbookConnector.java[lines=73..88]
----
+
Note that now the UI is a different form before, because the input is now a map.
+
image::datasense-ui.png[width="900"]
+
. In our Mule app, we cannot update the metadata and use our connector. And, as you can see, note that we have a map structure instead of a POJO:
+
image::datasense-map.png[width="900"]

To see how to test DataSense check our http://mulesoft.github.io/connector-certification-docs/advanced/index.html#_testing_metadata[Testing DataSense] guide.

// TODO
// === Adding @Query

== Adding Pagination

=== Implement Pagination
In order to show this feature you are going to add a processor that will call the searchWithQuery operation of the SDK.

You need to do 3 things in order to have a paginated operation:

[source,java,linenums]
----
include::{examplesdir}/java/v8/CookbookConnector.java[lines=209..216]
----
<1> Annotated your processor with @Paged.
<2> Return a ProviderAwarePagingDelegate
<3> Receive as one of your parameters a PagingConfiguration

--
When implementing your ProviderAwarePagingDelegate you need to specify two elements:

. The type of the list you will return in each page. In your case a Map<String,Object>

. The type of the Connector.

To create it use the Anypoint DevKit Component wizard and:

. Specify the package were you want to create it. In this example *org.mule.cookbook.pagination*

. Specify you want to create a ProviderAwarePagingDelegate.

. Set the class name as CookbookPagingDelegate
+
image::pagination-component.png[width="600"]

After that you just need to implement the methods required for you to handle the new page request.

You can find the full source code of the https://github.com/mulesoft/mule-cookbook-tutorial/blob/master/src/main/asciidoc/resources/java/v8/CookbookPagingDelegate.java[CookbookPagingDelegate].
--
NOTE: If you have a reconnection strategy, DevKit will automatically reconnect and retry to get a page. It is important that you handle the state of your PagingDelegate to make sure you retry the last page that was not retrieved.

See:

* xref:adding-query-pagination-support.adoc[Adding Query Pagination Support].

=== Using Pagination In Your Mule App

You can for example use a foreach in front of your paged processor:

Mule App:

image::pagination-example.png[width="600"]

XML:

[source,xml,linenums]
----
include::{examplesdir}/mule-app/pagination-example.xml[]
----

[[install-guide]]
== Installing a Connector

=== Using the Anypoint DevKit plugin

Installing the connector is basically the same as installing any Eclipse plugin.

[[steps-to-install]]
To install your connector from the DevKit plugin:

. Right-click your project name in Package Explorer, and click *Anypoint Connector* > *Install Or Update*.
+
image::install1.png[width="500"]
+
This triggers the DevKit Maven build tool, which generates an http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.pde.doc.user%2Fconcepts%2Fupdate_site.htm[update site] folder.
+
The files will be copied under the *dropins* folder located in the same directory as the AnypointStudio executable, and installed without the need of rebooting your AnypointStudio.
+
. You can now use your connector in a Mule app.
+
image::install2.png[width="600"]

[TIP]
====
To uninstall the connectors you can either use the shortcut from the UI or remove the folder from the *dropins* directory and reboot your AnypointStudio

image::uninstall.png[width="400"]
====

=== Installing from an UpdateSite.zip

Connectors can be installed manually by selecting the update site generated by DevKit:

. Open a command prompt or terminal and change directory to where the pom.xml file is for your project (in the Eclipse workspace).
. Run *mvn clean package*. This builds the connector. If the build succeeded, you should see the directory where the connector's "UpdateSite.zip" was generated, which is usually what you point Studio.
. Click *Help* > *Install New Software...*.
+
image::install-updatesite.png[width="600"]
+
. Click *Add* and in the new dialog look for the folder.
. Click the UpdateSite file, generated under your project's target folder.
+
image::install-updatesite2.png[width="600"]
+
You can either select the zip file named UpdateSite.zip or the folder update-site.
+
image::install-updatesite3.png[width="600"]
+
A popup will open showing the task that is performed.
[[install-dialog]]
image::install12.png[width="500"]
+
. Review the installation and update items, and accept the license agreement.
+
. Click *Finish* and restart Studio for the changes to be recognized, and your palette updated.
+
NOTE: JAR files are not signed during this run, so you will see a popup.
+
image::security-warning.png[width="600"]
+
. You can now use your connector in a Mule app.
+
image::install2.png[width="600"]

== Updating a Connector

To update your connector you can repeat the steps made for <<steps-to-install,installing>> it.

AnypointStudio will detect it is an update and perform the corresponding actions.

== Debugging Your Connector

After successfully installing your connector, you can start using your connector in a Mule application.
You can add breakpoints in the source code of the connector to debug it.
If your connector is a Community connector, the source code ships automatically in the installed connector.
If your connector is an Enterprise connector, you need to manually attach the source code of your JAR.

WARNING: To correctly debug your code, take into account that the Mule app you are running is using the latest installed version, so if you make changes, and you want to debug the Mule app, you need to re-install the connector.

Debugging your connector when running your test is as simple as debugging any Java class.

You just need to set a breakpoint in your connector code.

== Sharing My Connector

A connector can be installed in Anypoint Studio as an "update site".

Update sites are used to organize and export features so they can be installed as a component/package into Eclipse applications.

Update site generation means the included features (along with all plug-ins part of those features) are exported into an installable form. The exported plug-ins and features are put into two folders: "plug-ins" and "features". Two other files, "content.xml" and "artifacts.xml" are also generated and contain metadata for the exported files that make installation easier. These files, along with "site.xml", collectively form an Eclipse update site. To make the update site available to others you must make all these files available in a shared directory or website.

When building a connector, DevKit generates the necessary resources for you, so that you don't need to worry about generating it yourself.

You can use the Anypoint DevKit plugin to either install the connector on your current Studio, or export it as an update-site for others to use.


[[connector-structure]]
== Connector Structure

In order to see how all the components are related, let's create a Hello World connector:

. In Anypoint Studio, click *File* > *New* > *Anypoint Connector Project* or right-click your project name in Package Explorer and click *New* > *Anypoint Connector Project*:
+
image::new-connector-1.png[width="500"]
+
. Select the Connector Type you want to create. In this case, select *SDK Based*:
+
image::new0.png[width="500"]
+
. Specify the name of your connector and click *Finish*:
+
image::new-connector-2.png[width="500"]
+
This generates a project containing the structure and all required elements including a skeleton connector, images, sample docs, and basic tests for your connector.
+
image::new-connector-3.png[width="600"]
+
. Enable the DevKit view by clicking from the top bar *Window* > *Show view* > *Other*, and look for DevKit in the list.
+
image::enable-view.png[width="300", height="400"]

Your connector initially consists of message processors and user interface elements. Users can configure the UI elements in Anypoint Studio.

The DevKit makes it easy to install a connector in Studio. After you install it in Studio, users can search for your connector and drag it into a Mule flow.

Installing only requires right-clicking the name of the connector in Studio's Package Explorer, and clicking *Anypoint Connector* > *Install or Update*, completing the prompts, and restarting Studio, as you can see at the <<install-guide,install section>>. You can install at any time during coding. You can even install the starting skeleton connector.

Let's check the structure of the skeleton connector.

In this image you can see how most of the code maps into UI elements.

// TODO: Use 2 images of screenshots with the default layout

image::split-1-high.png[caption="Figure 1: ", title="View Structure and UI", alt="", width="800", "split-1-high.png"]

In this example, you can check how the code matches to XML and other UI elements.

// TODO: Use 2 images of screenshots with the default layout

image::split-2-high.png[caption="Figure 2: ", title="View configuration and XML", alt="", width="800", "split2"]

[NOTE]
====
`@ConnectionStrategy` annotation is deprecated. Users instead should use `@Config`.
====

[[configurable]]
== @Configurable and Parameter Modifiers

Optional parameters or configurable ones are elements that are not required, and therefore, there is no need for users to specify a value.

You can specify configurable fields (using `@Configurable`) inside your Connector Configuration classes, or as parameters of `@Processor` methods inside a `@Connector` class.

[source,java,linenums]
----
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.param.Optional;

//Inside the Configuration class

/**
 * Optional Field documentation
 */
@Configurable
@Optional
private String  optionalField;
//Getter and Setter of the field are required

//Inside your @Connector

/**
 * Optional parameter
 */
@Processor
public String sayHi(String firstName,@Optional String lastName ) {
    return "Hi "+firstName+" "+((lastName==null) ? "":lastName);
}
----

== @Default

When you want an optional parameter or configurable you can avoid the use of `@Optional` and just use the `@Default` annotation.

[source,java,linenums]
----
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.param.Default;

//Inside the Configuration class

/**
 *  Field with Default
 */
@Configurable
@Default("Hi")
private String  greeting;
//Getter and Setter of the field are required

//Inside your @Connector

/**
 * Default parameter
 */
@Processor
public String sayHi(String firstName,@Default("Unknown") String lastName ) {
    return greeting+" "+firstName+" "+lastName;
}
----

Another very important use of the `@Default` annotation is when building a connector that has DataSense.

== Adding OAuthV2

The Server can also provide the token using OAuth 2.0, instead of doing a login request.

In order to use OAuth in you connector you just need to annotate your strategy with the `@OAuth2` annotation.

If you only had the OAuth2 Configuration your `Config.java` would look like:

[source,java,linenums]
----
include::{examplesdir}/java/v9/OAuth2StandAloneConfig.java[]
----

All our operations now need to be marked with the @OAuthProtected, even our @Source.

In our Connector for example you will see:
[source,java,linenums]
----
include::{examplesdir}/java/v9/CookbookConnector.java[lines="113..129"]
----

Check https://github.com/mulesoft/mule-cookbook-tutorial/blob/master/src/main/asciidoc/resources/java/v9/CookbookConnector.java[full source] code.

See:

* xref:authentication.adoc[Authentication] documentation.
* xref:oauth-v2.adoc[OAuth V2].
* <<multiple-connection-strategies,Supporting Multiple Connection Strategies>>.

[[multiple-connection-strategies]]

== Multiple Configurations

If you want to have multiple connection configurations there are two things to take into account:

* All Configurations either need to implement the same interface or have a common parent class.
* The connector Config field needs to be declared either as the interface or as the common parent class.

If your configuration has common fields, they can be defined at a parent class.

In our connector, after the refactor the classes would look like this:

image::model.png[uml-model]
////
[plantuml,model,png]
----
title Multiple Configurations

ConnectorConfig <|-- ConnectionManagementConfig
ConnectorConfig <|-- OAuthConfig
CookBookConnector *- ConnectorConfig : config


abstract class ConnectorConfig {
- MuleCookBookClient client
- String endpoint
}

class CookBookConnector {

}

class ConnectionManagementConfig {
}

class OAuthConfig {
-String consumerKey
-String consumerSecret
-String accessToken
}
----
////

See:

* https://github.com/mulesoft/mule-cookbook-tutorial/blob/master/src/main/asciidoc/resources/java/v9/CookbookConnector.java[Connector] source code.

* https://github.com/mulesoft/mule-cookbook-tutorial/blob/master/src/main/asciidoc/resources/java/v9/ConnectorConfig.java[Base Config] source code.

* https://github.com/mulesoft/mule-cookbook-tutorial/blob/master/src/main/asciidoc/resources/java/v9/ConnectionManagementConfig.java[Connection Management Config] source code.

* https://github.com/mulesoft/mule-cookbook-tutorial/blob/master/src/main/asciidoc/resources/java/v9/OAuthConfig.java[OAuth2 Config] source code.

== Adding @Source

=== What is a Source?

In some cases it is necessary to create Message Sources instead of Message Processors.

Basically, a Message Source receives or generates new messages to be processed by Mule.
One of the use cases for a Message Source is implementing Streaming APIs. The `@Source` annotation marks a method inside a `@Connector` annotated class as callable from a Mule flow and capable of generating Mule events. Each marked method will have a Message Source generated. The method must receive a SourceCallback as one of its arguments that represents the next message processor in the chain. It does not matter the order in which this parameter appears as long it is present in the method signature.

== Implementing a Message Source

As an example, we are going to use the GetRecentlyAdded method.

. Inside your `@Connector` type source and use Ctrl + Space bar to display the templates.
+
image::source-template.png[width="600"]

. Create a `@Source` that consumes the Get Recently Updated on the Connector using a callback
+
[source,java,linenums]
----
include::{examplesdir}/java/v7/CookbookConnector.java[lines=73..90]
----

. Install this new version

. On your flow now just drag and drop the Cookbook Connector, and you will see that is automatically while generate a flow.
+
image::source-example.png[width="600"]
+
. Add a logger and debug to see that the payload now has your recipes.
+
Mule App:
+
image::source-debug.png[width="600"]
+
XML:
+
[source,xml,linenums]
----
include::{examplesdir}/mule-app/source-example.xml[]
----


== About Adding a Transformer

Transformers convert message payloads to formats expected by their destinations. Mule ESB provides many standard transformers, which users can configure using elements and attributes in a Mule XML configuration file.

Sometimes it's useful to build your own custom transformers.

Annotating a method with @Transformer signals the DevKit to export a method functionality as a transformer. You need to declare Transformers in classes annotated with @Module or @Connector and you can declare more than one transformer in a single class. It is possible to declare transformers, message processors, and message sources all in the same class.

A `@Transformer` annotated method must:

* Be static
* Be public
* Not return void
* Not return java.lang.Object
* Receive exactly one argument
* Be inside a class annotated with `@Connector`

=== Creating a Transformer

In our case, we are creating a transformer that converts a +List<Recipe>+ into a +List<Map<String,Object>>+, that way we don't need to modify our existing operation, and yet we can use the output of it in operations that receive a +List<Map<String,Object>>+.

[source,java,linenums]
----
include::{examplesdir}/java/v6/CookbookConnector.java[lines=163..169]
----

=== Using Your Transformer in a Mule App

To use your transformer, just drag and drop it from the palette and build a flow.

Here we are using it explicitly to map transform the recipes into a Map.

Mule App:

image::transformer-explicit.png[width="600"]

XML:

[source,xml,linenums]
----
include::{examplesdir}/mule-app/transformer-example.xml[]
----

Transformers can also be used implicitly as long as only one transformer is found to resolve the type.

. Define another transformer that can transform Recipe object into Map<String,Object>
+
[source,java,linenums]
----
include::{examplesdir}/java/v8/CookbookConnector.java[lines=226..232]
----
+
. Install the connector.
+
. In your Mule app, create a flow that takes the first item of the list and add an update operation after it. Don't use the transformer.
+
image::transformer-implicitly.png[width="600"]
+
XML:
+
[source,xml,linenums]
----
include::{examplesdir}/mule-app/transformer2-example.xml[]
----
+
. Run the example and see that the flow will execute successfully.

== Using @Password

When using the `@Password` in a @`Connect` parameters, it generates a masked input field in the UI.

[source,java,linenums]
----
include::{examplesdir}/java/v2/ConnectorConfig.java[lines=41..43]
----

In Studio this translates into:

image::password.png[width="500"]

// ==== Using @Placement

// Defines the placement of a configurable attribute in the Anypoint Studio configuration.

//TODO

== Build a Connector for an API

APIs are exposed in several ways. To start using your API, you should set up a few things before you can use it inside your connector.

=== SDK Client

If you have an SDK all you need to do is to include the Maven dependency for your jar in the pom.xml

For example in our case, to consume the SDK for the Cookbook we can add the dependency.

[source,xml,linenums]
----
<dependencies>
  <dependency>
    <groupId>foo.sdk.group.id</groupId>
    <artifactId>foo.sdk.artifact.id</artifactId>
    <version>${sdk.version}</version>
  </dependency>
</dependencies>
----

=== SOAP API

If you have a wsdl, the easiest way to build a connector is to create a client using CXF http://cxf.apache.org/docs/wsdl-to-java.html[wsdl2java].

You can configure the CXF goal in your `pom.xml` file very easily. The full documentation is at the Apache  http://cxf.apache.org/docs/maven-cxf-codegen-plugin-wsdl-to-java.html[CXF site].

For example, in your `pom.xml` file, you can add the following plus all required dependencies:

[source,xml,linenums]
----
<build>
  <plugins>
    <!-- CXF Code generation -->
    <plugin>
      <groupId>org.apache.cxf</groupId>
      <artifactId>cxf-codegen-plugin</artifactId>
      <version>${cxf.version}</version>
      <executions>
        <execution>
          <phase>clean</phase> <!-- This is required for it to work with DevKit -->
          <goals>
            <goal>wsdl2java</goal>
          </goals>
          <configuration>
            <wsdlOptions>
              <wsdlOption>
                <wsdl>${basedir}/src/main/resources/wsdl/IMuleCookBookService.wsdl</wsdl>
                <autoNameResolution>true</autoNameResolution>
                <extendedSoapHeaders>false</extendedSoapHeaders>
                <extraargs>
                  <extraarg>-xjc-Xbg</extraarg>
                   <extraarg>-xjc-Xcollection-setter-injector</extraarg>
                  <extraarg>-p</extraarg>
                  <extraarg>org.mule.modules.wsdl.api</extraarg>
                </extraargs>
              </wsdlOption>
            </wsdlOptions>
          </configuration>
         </execution>
      </executions>
      <dependencies>
        <!-- Boolean Getters -->
        <dependency>
          <groupId>org.apache.cxf.xjcplugins</groupId>
          <artifactId>cxf-xjc-boolean</artifactId>
          <version>${cxf.version.boolean}</version>
        </dependency>
        <!-- Collection Setters -->
        <dependency>
          <groupId>net.java.dev.vcc.thirdparty</groupId>
          <artifactId>collection-setter-injector</artifactId>
          <version>0.5.0-1</version>
        </dependency>
      </dependencies>
    </plugin>
  </plugins>
</build>
----

If you use the DevKit plugin it generates everything for you to get started, you just need to specify the WSDL location on your computer.

=== REST API

Write the request using any library that helps you make HTTP Requests.

We recommend using Jersey 2.11, which is provided in Mule version 3.6.0 and later.

To make sure you always use the right version, add the following dependency to your connector `pom.xml`.

[source,xml,linenums]
----
<dependencies>
    <dependency>
        <groupId>org.mule.modules</groupId>
        <artifactId>mule-module-jersey</artifactId>
        <version>${mule.version}</version>
        <scope>provided</scope>
    </dependency>
</dependencies>
----

Example GET request:

[source,java,linenums]
----
ClientConfig clientConfig = new ClientConfig();
Client client = ClientBuilder.newClient(clientConfig);
WebTarget webTarget = client.target("http://example.com/rest"); // # <1>
WebTarget resourceWebTarget = webTarget.path("resource");
WebTarget helloworldWebTarget = resourceWebTarget.path("helloworld"); // # <2>
WebTarget helloworldWebTargetWithQueryParam =
        helloworldWebTarget.queryParam("greeting", "Hi World!"); // # <3>

Invocation.Builder invocationBuilder =
        helloworldWebTargetWithQueryParam.request(MediaType.APPLICATION_JSON_TYPE); // # <4>

Response response = invocationBuilder.get(); // # <5>
System.out.println(response.getStatus());
System.out.println(response.readEntity(String.class));
----
<1> The client is ready to make a request to URL `+http://example.com/rest+`.
<2> Add paths for `+http://example.com/rest/resource/helloworld+`.
<3> Configure a query param in the form of `+http://example.com/rest/resource/helloworld?greeting=Hi+World%21+`.
<4> Specify we want the reply in JSON format.
<5> Make a GET request.

=== REST Server for Cookbook

If testing the three resources included in the Cookbook REST server, set up your connector to be SDK-based and select OAuth v2 as the authentication mechanism.

For more information, see the https://jersey.github.io/[Jersey client] documentation.
